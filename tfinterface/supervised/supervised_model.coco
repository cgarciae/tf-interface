from abc import abstractmethod
import random
import tensorflow as tf

from tfinterface.model_base import ModelBase
from tfinterface.interfaces import SupervisedInterface, TrainerInterface
from tfinterface.utils import TENSOR

class SupervisedModel(ModelBase, SupervisedInterface):

    def predict(self, X, **kwargs):
        feed_dict = self.predict_feed(X, **kwargs)
        return self.sess.run(self.h, feed_dict=feed_dict)

    def fit_feed(self, x, y, **kwargs):
        return {self.x: x, self.y: y}

    def predict_feed(self, x, **kwargs):
        return {self.x: x}

    def fit(self, *args, **kwargs):
        self.trainer.fit(*args, **kwargs)

    @property
    def default_trainer(self):
        return SupervisedTrainer


class SupervisedTrainer(TrainerInterface):
    """docstring for SupervisedTrainer."""
    def __init__(self, model):
        super(SupervisedTrainer, self).__init__()
        self.model = model


    def fit(self, *args, **kwargs):
        batch_size = kwargs.get('batch_size', 64)
        learning_rate = kwargs.get('learning_rate', 0.01)
        epochs = kwargs.get('epochs', 2000)

        model = self.model

        for i in range(epochs):
            [_, summaries] = model.sess.run([model.update, model.summaries], feed_dict=self.feed_fn(batch_size, args, kwargs))

            if isinstance(model.global_step, (tf.Tensor, tf.Variable)):
                global_step = model.sess.run(model.global_step)
            else:
                model.global_step += 1
                global_step = model.global_step

            if summaries is not None:
                model.writer.add_summary(summaries, global_step=global_step)

    def feed_fn(self, batch_size, args, kwargs):
        if batch_size is not None:
            vars = self.random_batch(*args, **kwargs)
            return self.model.fit_feed(*args, **kwargs)
        else:
            return {}

    def random_batch(self, *vars, **kwargs):
        total_length = len(vars[0])
        batch_size = kwargs.get('batch_size', min(64, total_length))

        idxs = random.sample(range(total_length), batch_size)
        return tuple([ var[idxs] for var in vars ])


