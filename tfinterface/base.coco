import tensorflow as tf
from copy import copy
from .utils import TENSOR, Required
import numpy as np

from abc import ABCMeta, abstractmethod

class RequiredModel(Required): pass
MODEL = RequiredModel()

class RequiredInputs(Required): pass
INPUTS = RequiredInputs()


class Base(object):
    __metaclass__ = ABCMeta

    @abstractmethod
    def _build(self, *args, **kwargs): pass

    def __init__(self, name, graph=None, sess=None):
        self.name = name
        self.template = tf.make_template(self.name, self.__class__._build)
        self.graph = graph if graph else tf.get_default_graph()
        self.sess = sess if sess else tf.get_default_session() if tf.get_default_session() else tf.Session(graph=self.graph)

    def __call__(self, *args, **kwargs):
        new = copy(self)

        with new.graph.as_default():
            new.template(new, *args, **kwargs)

        return new

class Inputs(Base):
    __metaclass__ = ABCMeta

    @abstractmethod
    def fit_feed(self, *args, **kwargs): pass

    @abstractmethod
    def predict_feed(self, *args, **kwargs): pass


class GeneralInputs(Inputs):
    """docstring for GeneralInputs."""
    def __init__(self, name, graph=None, sess=None, **input_specs):
        super(GeneralInputs, self).__init__(name, graph=graph, sess=sess)
        self._input_specs = input_specs

    def _build(self, **input_overrides):
        input_specs = self._input_specs.copy()
        input_specs.update(input_overrides)

        for name, spec in input_specs.items():

            if type(spec) is not dict:

                if type(spec) is tuple:
                    spec = dict(dtype=tf.float32, shape=spec)

                elif hasattr(spec, "__call__"):
                    spec = dict(tensor_fn=spec)

                else:
                    spec = dict(value=spec)


            if "shape" in spec:
                dtype = spec.get("dtype", tf.float32)
                shape = spec.get("shape")
                tensor = tf.placeholder(dtype=dtype, shape=shape, name=name)

            elif "value" in spec:
                value = spec.get("value")
                dtype = spec.get("dtype", None)
                tensor = tf.convert_to_tensor(value, dtype=dtype, name=name)

            elif "tensor_fn" in spec:
                tensor_fn = spec.get("tensor_fn")
                tensor = tensor_fn()


            setattr(self, name, tensor)


    def get_feed(self, **kwargs):
        return ({
            getattr(self, key) : value for key, value in kwargs.items()
        })



class ModelBase(Base):
    __metaclass__ = ABCMeta

    def __init__(self, name, graph=None, sess=None, model_path="model", logs_path="logs", seed=None):
        super(ModelBase, self).__init__(name, graph=graph, sess=sess)

        self.seed = seed
        self.model_path = model_path
        self.logs_path = logs_path
        self.saver = tf.train.Saver(allow_empty=True)

        if self.seed is not None:
            with self.graph.as_default():
                tf.set_random_seed(self.seed)


    def initialize(self, restore=False, model_path=None):
        if not restore:
            self.sess.run(tf.global_variables_initializer())
        else:
            model_path = self.model_path if not model_path else model_path
            self.saver.restore(self.sess, model_path)

        return self

    def save(self, model_path=None):
        model_path = self.model_path if not model_path else model_path
        self.saver.save(self.sess, model_path)

        return self

class Model(ModelBase):

    @abstractmethod
    def predict(self, *args, **kwargs): pass


class Trainer(ModelBase):

    @abstractmethod
    def fit(self, *args, **kwargs): pass
